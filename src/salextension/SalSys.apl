.head 0 +  Application Description: Centura SQLWindows/32 Standard Application Template
.head 1 -  Outline Version - 4.0.34
.head 1 +  Design-time Settings
.data VIEWINFO
0000: 6F00000001000000 FFFF01000D004347 5458566965775374 6174650400010000
0020: 0000000000CF0000 002C000000020000 0003000000FFFFFF FFFFFFFFFFFCFFFF
0040: FFE9FFFFFFFFFFFF FF000000007C0200 004D010000010000 0001000000010000
0060: 000F4170706C6963 6174696F6E497465 6D00000000
.enddata
.head 2 -  Outline Window State: Normal
.head 2 +  Outline Window Location and Size
.data VIEWINFO
0000: 6600040003002D00 0000000000000000 0000B71E5D0E0500 1D00FFFF4D61696E
0020: 0000000000000000 0000000000000000 0000003B00010000 00000000000000E9
0040: 1E800A00008600FF FF496E7465726E61 6C2046756E637469 6F6E730000000000
0060: 0000000000000000 0000000000003200 0100000000000000 0000E91E800A0000
0080: DF00FFFF56617269 61626C6573000000 0000000000000000 0000000000000000
00A0: 3000010000000000 00000000F51E100D 0000F400FFFF436C 6173736573000000
00C0: 0000000000000000 0000000000000000
.enddata
.data VIEWSIZE
0000: D000
.enddata
.head 3 -  Left: -0.013"
.head 3 -  Top: 0.0"
.head 3 -  Width:  8.013"
.head 3 -  Height: 4.969"
.head 2 +  Options Box Location
.data VIEWINFO
0000: D4180909B80B1A00
.enddata
.data VIEWSIZE
0000: 0800
.enddata
.head 3 -  Visible? Yes
.head 3 -  Left: 4.15"
.head 3 -  Top: 1.885"
.head 3 -  Width:  3.8"
.head 3 -  Height: 2.073"
.head 2 +  Class Editor Location
.head 3 -  Visible? No
.head 3 -  Left: 0.575"
.head 3 -  Top: 0.094"
.head 3 -  Width:  5.063"
.head 3 -  Height: 2.719"
.head 2 +  Tool Palette Location
.head 3 -  Visible? No
.head 3 -  Left: 6.388"
.head 3 -  Top: 0.729"
.head 2 -  Fully Qualified External References? Yes
.head 2 -  Reject Multiple Window Instances? No
.head 2 -  Enable Runtime Checks Of External References? Yes
.head 2 -  Use Release 4.0 Scope Rules? No
.head 2 -  Edit Fields Read Only On Disable? No
.head 1 -  Libraries
.head 1 +  Global Declarations
.head 2 +  Window Defaults
.head 3 +  Tool Bar
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Form Window
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Dialog Box
.head 4 -  Display Style? Etched
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Top Level Table Window
.head 4 -  Font Name: MS Sans Serif
.head 4 -  Font Size: 8
.head 4 -  Font Enhancement: System Default
.head 4 -  Text Color: System Default
.head 4 -  Background Color: System Default
.head 3 +  Data Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Multiline Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Spin Field
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Background Text
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Pushbutton
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Radio Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Check Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Option Button
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 3 +  Group Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Child Table Window
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  List Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Combo Box
.head 4 -  Font Name: Use Parent
.head 4 -  Font Size: Use Parent
.head 4 -  Font Enhancement: Use Parent
.head 4 -  Text Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 3 +  Line
.head 4 -  Line Color: Use Parent
.head 3 +  Frame
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: 3D Face Color
.head 3 +  Picture
.head 4 -  Border Color: Use Parent
.head 4 -  Background Color: Use Parent
.head 2 +  Formats
.head 3 -  Number: 0'%'
.head 3 -  Number: #0
.head 3 -  Number: ###000
.head 3 -  Number: ###000;'($'###000')'
.head 3 -  Date/Time: hh:mm:ss AMPM
.head 3 -  Date/Time: M/d/yy
.head 3 -  Date/Time: MM-dd-yy
.head 3 -  Date/Time: dd-MMM-yyyy
.head 3 -  Date/Time: MMM d, yyyy
.head 3 -  Date/Time: MMM d, yyyy hh:mm AMPM
.head 3 -  Date/Time: MMMM d, yyyy hh:mm AMPM
.head 2 -  External Functions
.head 2 +  Constants
.data CCDATA
0000: 3000000000000000 0000000000000000 00000000
.enddata
.data CCSIZE
0000: 1400
.enddata
.head 3 +  System
.head 4 -  ! ! ! ! ! ( Registry )
.head 4 -  Number: HKEY_CLASSES_ROOT 		= 0x80000000
.head 4 -  Number: HKEY_CURRENT_USER 		= 0x80000001
.head 4 -  Number: HKEY_LOCAL_MACHINE 		= 0x80000002
.head 4 -  Number: HKEY_USERS	 		= 0x80000003
.head 4 -  Number: HKEY_PERFORMANCE_DATA 	= 0x80000004
.head 4 -  Number: HKEY_CURRENT_COFIG	 	= 0x80000005
.head 4 -  Number: HKEY_DYN_DATA		 	= 0x80000006
.head 4 -  Number: REG_KEY_READ = 0x0001 | 0x0008 | 0x0010
.head 4 -  Number: REG_ERR_SUCCESS = 0
.head 4 -  Number: REG_ERR_FILE_NOT_FOUND = 2
.head 4 -  Number: REG_ERR_MORE_DATA = 234
.head 3 +  User
.head 4 -  ! !
.head 4 -  ! ! ! *** Printer Attributes
.head 4 -  Number: PRINTER_ATT_QUEUED		= 0x00000001
.head 4 -  Number: PRINTER_ATT_DIRECT		= 0x00000002
.head 4 -  Number: PRINTER_ATT_DEFAULT		= 0x00000004
.head 4 -  Number: PRINTER_ATT_SHARED		= 0x00000008
.head 4 -  Number: PRINTER_ATT_NETWORK		= 0x00000010
.head 4 -  Number: PRINTER_ATT_HIDDEN		= 0x00000020
.head 4 -  Number: PRINTER_ATT_LOCAL		= 0x00000040
.head 4 -  Number: PRINTER_ATT_ENABLE_DEVQ	= 0x00000080
.head 4 -  Number: PRINTER_ATT_KEEPPRINTEDJOBS	= 0x00000100
.head 4 -  Number: PRINTER_ATT_COMPLETE_FIRST	= 0x00000200
.head 4 -  Number: PRINTER_ATT_WORK_OFFLINE	= 0x00000400
.head 4 -  Number: PRINTER_ATT_ENABLE_BIDI	= 0x00000800
.head 4 -  Number: PRINTER_ATT_RAW_ONLY		= 0x00001000
.head 4 -  Number: PRINTER_ATT_PUBLISHED		= 0x00002000
.head 4 -  ! !
.head 4 -  ! ! *** Port Attributes
.head 4 -  Number: PORT_TYPE_WRITE		= 0x0001
.head 4 -  Number: PORT_TYPE_READ 		= 0x0002
.head 4 -  Number: PORT_TYPE_REDIRECTED 		= 0x0004
.head 4 -  Number: PORT_TYPE_NET_ATTACHED 	= 0x0008
.head 3 -  Enumerations
.head 2 -  Resources
.head 2 -  Variables
.head 2 +  Internal Functions
.head 3 +  Function: SalSysGetProcessList
.head 4 -  Description: author: 	Petra Zamburek  based on a sample from Daniel Mock posted November 1999
date:  	2000-11-27
version 	1.0

desc:
Returns all running process IDs and process names

example:
Call SalSysGetProcessList( lsProcessNames, lnProcessIDs )
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Receive String: rsaProcessNames[*]
.head 5 -  Receive Number: rnaProcessesID[*]
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nRet
.head 5 -  Boolean: bOk
.head 5 -  Number: nCounter
.head 5 -  Number: nArrayCounter
.head 5 -  !
.head 5 -  String: sBuffer
.head 5 -  Number: nProcessBlocks
.head 5 -  Number: nBlocks
.head 5 -  Number: nBlocksNeeded
.head 5 -  Number: nMemBlock
.head 4 +  Actions
.head 5 -  Set nBlocks = 8
.head 5 -  Set nBlocksNeeded = 96
.head 5 +  While nBlocks <= nBlocksNeeded
.head 6 -  Set nBlocks = nBlocks*2
.head 6 -  Set bOk = SalStrSetBufferLength( sBuffer, (nBlocks*4) )
.head 6 -  Set nMemBlock = CStructAllocFarMem( nBlocks*4 )
.head 6 -  Set nRet = CStructCopyToFarMem( nMemBlock, sBuffer, (nBlocks*4) )
.head 6 -  If EnumProcesses( nMemBlock, nBlocks, nBlocksNeeded )
.head 6 -  Set nRet = CStructCopyFromFarMem( nMemBlock, sBuffer, (nBlocks*4) )
.head 6 -  Set nRet = CStructFreeFarMem( nMemBlock )
.head 5 -  Set nCounter = 0
.head 5 -  Set nArrayCounter = 0
.head 5 +  While nCounter < (nBlocksNeeded/4)
.head 6 -  Set rnaProcessesID[nArrayCounter] = CStructGetLong( sBuffer, (nCounter*4 ) )
.head 6 -  ! if functions passes, then inc array counter, otherwise skip over it
.head 6 +  If SalSysGetModuleName( rnaProcessesID[nArrayCounter], rsaProcessNames[nArrayCounter] )
.head 7 -  Set nArrayCounter = nArrayCounter + 1
.head 6 +  Else
.head 7 -  Set rnaProcessesID[nArrayCounter] = NUMBER_Null
.head 7 -  Set rsaProcessNames[nArrayCounter] = ''
.head 6 -  Set nCounter = nCounter + 1
.head 5 -  Return TRUE
.head 3 +  Function: SalSysGetModuleList
.head 4 -  Description: author: 	Petra Zamburek  based on a sample from Daniel Mock posted November 1999
date:  	2000-11-27
version 	1.0

desc:
Returns all modules to a process

example:
Call SalSysGetModuleList(lnProcessID, lsModuleNames)
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Number: nProcessID
.head 5 -  Receive String: sModules[*]
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nProcessHandle
.head 5 -  Number: nRet
.head 5 -  Boolean: bOk
.head 5 -  Number: nCounter
.head 5 -  !
.head 5 -  String: sBuffer
.head 5 -  Number: nProcessBlocks
.head 5 -  Number: nBlocks
.head 5 -  Number: nBlocksNeeded
.head 5 -  Number: nMemBlock
.head 5 -  Number: nSize
.head 5 -  Number: nModuleID
.head 5 -  String: sModuleName
.head 4 +  Actions
.head 5 -  Set nProcessHandle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, nProcessID )
.head 5 +  If nProcessHandle = 0
.head 6 -  Return FALSE
.head 5 -  Set nBlocks = 8
.head 5 -  Set nBlocksNeeded = 96
.head 5 +  While nBlocks <= nBlocksNeeded
.head 6 -  Set nBlocks = nBlocks*2
.head 6 -  Set bOk = SalStrSetBufferLength( sBuffer, (nBlocks*4) )
.head 6 -  Set nMemBlock = CStructAllocFarMem( nBlocks*4 )
.head 6 -  Set nRet = CStructCopyToFarMem( nMemBlock, sBuffer, (nBlocks*4) )
.head 6 -  Set bOk = EnumProcessModules( nProcessHandle, nMemBlock, nBlocks, nBlocksNeeded )
.head 6 -  Set nRet = CStructCopyFromFarMem( nMemBlock, sBuffer, (nBlocks*4) )
.head 6 -  Set nRet = CStructFreeFarMem( nMemBlock )
.head 5 -  Set nCounter = 0
.head 5 +  While nCounter < (nBlocksNeeded/4)
.head 6 -  Set nModuleID = CStructGetLong( sBuffer, (nCounter*4 ) )
.head 6 -  Set nSize = 200
.head 6 -  Set bOk = SalStrSetBufferLength( sModuleName, nSize )
.head 6 -  Set nRet = GetModuleFileNameExA( nProcessHandle, nModuleID, sModuleName, nSize )
.head 6 -  Set sModules[nCounter] = sModuleName
.head 6 -  Set nCounter = nCounter + 1
.head 5 -  Return TRUE
.head 3 +  Function: SalSysGetModuleName
.head 4 -  Description: author: 	Petra Zamburek  based on a sample from Daniel Mock posted November 1999
date:  	2000-11-27
version 	1.0

desc:
Returns a Moduel names for a processID
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  Number: nProcessID
.head 5 -  Receive String: sModule
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nRet
.head 5 -  Boolean: bOk
.head 5 -  Number: nCounter
.head 5 -  Number: nProcessHandle
.head 5 -  !
.head 5 -  String: sBuffer
.head 5 -  Number: nProcessBlocks
.head 5 -  Number: nBlocks
.head 5 -  Number: nBlocksNeeded
.head 5 -  Number: nMemBlock
.head 5 -  Number: nSize
.head 5 -  Number: nModuleID
.head 5 -  String: sModuleName
.head 4 +  Actions
.head 5 -  Set sModuleName = ''
.head 5 -  Set nProcessHandle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, nProcessID )
.head 5 +  If nProcessHandle = 0
.head 6 -  Set sModule = ''
.head 6 -  Return FALSE
.head 5 -  Set nSize = 4
.head 5 -  Set nBlocks = nSize
.head 5 -  Set bOk = SalStrSetBufferLength( sBuffer, (nSize) )
.head 5 -  Set nMemBlock = CStructAllocFarMem( nSize )
.head 5 -  Set nRet = CStructCopyToFarMem( nMemBlock, sBuffer, (nSize) )
.head 5 -  Set bOk = EnumProcessModules( nProcessHandle, nMemBlock, nBlocks, nBlocksNeeded )
.head 5 -  Set nRet = CStructCopyFromFarMem( nMemBlock, sBuffer, nSize )
.head 5 -  Set bOk = CStructFreeFarMem( nMemBlock )
.head 5 -  Set nModuleID = CStructGetLong( sBuffer, 0 )
.head 5 -  Set nSize = 200
.head 5 -  Set bOk = SalStrSetBufferLength( sModuleName, nSize )
.head 5 -  Set nRet = GetModuleFileNameExA( nProcessHandle, nModuleID, sModuleName, nSize )
.head 5 -  !
.head 5 -  Set nRet = GetLastError ()
.head 5 -  !
.head 5 -  Set sModule = sModuleName
.head 5 -  Call CloseHandle( nProcessHandle )
.head 5 -  Return TRUE
.head 3 +  Function: SalSysRegistryRead
.head 4 -  Description: 
author:	R. J. Burke (i think)
date:
version:

desc:
This function reads a value from the registry.
Returns TRUE, if the value was found
Returns FALSE, in all other cases
allowed RootKeys:	HKEY_CLASSES_ROOT
		HKEY_CURRENT_USER
		HKEY_LOCAL_MACHINE
		HKEY_USERS
		HKEY_PERFORMANCE_DAT
		HKEY_CURRENT_COFIG
		HKEY_DYN_DATA

example:
If SalSysRegistryRead(HKEY_LOCAL_MACHINE,'SOFTWARE\\Centura','TestItem',sValue)
  .. all Ok
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  ! rootkey of the registry
.head 5 +  Number: pnRegistryRootKey
.head 6 -  ! allowed RootKeys:	HKEY_CLASSES_ROOT
		HKEY_CURRENT_USER
		HKEY_LOCAL_MACHINE
		HKEY_USERS
		HKEY_PERFORMANCE_DAT
		HKEY_CURRENT_COFIG
		HKEY_DYN_DATA
.head 5 -  ! subkey
.head 5 +  String: psRegistrySubKey
.head 6 -  ! subkey, somthing like 'SOFTWARE\\Centura'
.head 5 -  ! item
.head 5 +  String: psRegistryItem
.head 6 -  ! the itemname e.g. WindowPosX
.head 5 -  ! variable for the result
.head 5 -  Receive String: psRegistryData
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! handle of the registry-key
.head 5 -  Number: lnRegistrySubKey
.head 5 -  Number: lnLength
.head 5 -  Number: lnError
.head 4 +  Actions
.head 5 -  ! open the registry
.head 5 -  Set lnError = RegOpenKeyExA (pnRegistryRootKey, psRegistrySubKey, 0, REG_KEY_READ, lnRegistrySubKey)
.head 5 -  ! check, if the registry-key was not found
.head 5 +  If lnError = REG_ERR_FILE_NOT_FOUND
.head 6 -  Return FALSE
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  Return FALSE
.head 5 -  ! initialize buffer with a defaul-value
.head 5 -  Set lnLength = 50
.head 5 -  Call SalStrSetBufferLength (psRegistryData, lnLength + 1)
.head 5 -  ! read the value
.head 5 -  Set lnError = RegQueryValueExA (lnRegistrySubKey, psRegistryItem, NUMBER_Null, 0, psRegistryData, lnLength)
.head 5 -  ! if the buffer was too small, the required length for the buffer is in _nLength and the read can be repeated
.head 5 +  If lnError = REG_ERR_MORE_DATA
.head 6 -  Call SalStrSetBufferLength (psRegistryData, lnLength + 1)
.head 6 -  Set lnError = RegQueryValueExA (lnRegistrySubKey, psRegistryItem, NUMBER_Null, 0, psRegistryData, lnLength)
.head 5 -  ! check, if the registry-key was not found
.head 5 +  If lnError = REG_ERR_FILE_NOT_FOUND
.head 6 -  Return FALSE
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  ! close registry
.head 6 -  Call RegCloseKey (lnRegistrySubKey)
.head 6 -  Return FALSE
.head 5 -  ! close registry
.head 5 -  Set lnError = RegCloseKey (lnRegistrySubKey)
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  Return FALSE
.head 5 -  Return TRUE
.head 3 +  Function: SalSysRegistryWrite
.head 4 -  Description: 
autor:	R. J. Burke (i think)
date:
version:

desc:
This function writes a value to the registry.
Returns TRUE, if the value was written
Returns FALSE, in all other cases
allowed RootKeys:	HKEY_CLASSES_ROOT
		HKEY_CURRENT_USER
		HKEY_LOCAL_MACHINE
		HKEY_USERS
		HKEY_PERFORMANCE_DAT
		HKEY_CURRENT_COFIG
		HKEY_DYN_DATA

example:
If SalSysRegistryWrite(HKEY_LOCAL_MACHINE,'SOFTWARE\\Centura','TestItem','Test')
  .. all Ok
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  ! rootkey of the registry
.head 5 +  Number: pnRegistryRootKey
.head 6 -  ! allowed RootKeys:	HKEY_CLASSES_ROOT
		HKEY_CURRENT_USER
		HKEY_LOCAL_MACHINE
		HKEY_USERS
		HKEY_PERFORMANCE_DAT
		HKEY_CURRENT_COFIG
		HKEY_DYN_DATA
.head 5 -  ! subkey
.head 5 +  String: psRegistrySubKey
.head 6 -  ! subkey, somthing like 'SOFTWARE\\Centura'
.head 5 -  ! item
.head 5 +  String: psRegistryItem
.head 6 -  ! the itemname e.g. WindowPosX
.head 5 -  ! value
.head 5 -  String: psRegistryData
.head 5 -  ! the value 
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: lnRegistryKey
.head 5 -  Number: lnLength
.head 5 -  Number: lnError
.head 4 +  Actions
.head 5 -  ! if the key doesn't exist: create key
.head 5 -  Set lnError = RegCreateKeyA (pnRegistryRootKey, psRegistrySubKey, lnRegistryKey)
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  Return FALSE
.head 5 -  ! write value to the regisry
.head 5 -  Set lnLength = SalStrLength (psRegistryData) + 1
.head 5 -  Set lnError = RegSetValueExA (lnRegistryKey, psRegistryItem, NUMBER_Null, 1, psRegistryData, lnLength)
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  ! close registry
.head 6 -  Call RegCloseKey (lnRegistryKey)
.head 6 -  Return FALSE
.head 5 -  ! close registry
.head 5 -  Set lnError = RegCloseKey (lnRegistryKey)
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  Return FALSE
.head 5 -  Return TRUE
.head 3 +  Function: SalSysRegistryDeleteItem
.head 4 -  Description: autor:	R. J. Burke (i think)
date:
version:

desc:
This function deletes a item and it´s avlue from the registry.
Returns TRUE, if the value was deleted
allowed RootKeys:	HKEY_CLASSES_ROOT
		HKEY_CURRENT_USER
		HKEY_LOCAL_MACHINE
		HKEY_USERS
		HKEY_PERFORMANCE_DAT
		HKEY_CURRENT_COFIG
		HKEY_DYN_DATA

.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 +  Number: pnRegistryRootKey
.head 6 -  ! allowed RootKeys:	HKEY_CLASSES_ROOT
		HKEY_CURRENT_USER
		HKEY_LOCAL_MACHINE
		HKEY_USERS
		HKEY_PERFORMANCE_DAT
		HKEY_CURRENT_COFIG
		HKEY_DYN_DATA
.head 5 +  String: psRegistrySubKey
.head 6 -  ! subkey, somthing like 'SOFTWARE\\Centura'
.head 5 +  String: psRegistryItem
.head 6 -  ! the itemname e.g. WindowPosX
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  ! handle of the registry-key
.head 5 -  Number: lnRegistrySubKey
.head 5 -  Number: lnLength
.head 5 -  Number: lnError
.head 4 +  Actions
.head 5 -  ! open the registry
.head 5 -  Set lnError = RegOpenKeyExA (pnRegistryRootKey, psRegistrySubKey, 0, 0x000E000F, lnRegistrySubKey)
.head 5 -  ! check, if the registry-key was not found
.head 5 +  If lnError = REG_ERR_FILE_NOT_FOUND
.head 6 -  Return FALSE
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  Return FALSE
.head 5 -  ! delete the item
.head 5 -  Set lnError = RegDeleteValueA (lnRegistrySubKey, psRegistryItem)
.head 5 -  Set lnError = RegCloseKey (lnRegistrySubKey)
.head 5 +  If lnError != REG_ERR_SUCCESS
.head 6 -  Return FALSE
.head 5 -  Return TRUE
.head 3 +  Function: SalSysGetComputerName
.head 4 -  Description: 
author: ???
date:     ???
version: 1.01 

desc:
Returns the computername

example:
Set sComputername =  SalSysGetComputerName()
.head 4 +  Returns
.head 5 -  String:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nSize
.head 5 -  String: sCOMPUTERNAME
.head 4 +  Actions
.head 5 -  Set nSize = 250
.head 5 -  Call SalStrSetBufferLength( sCOMPUTERNAME, nSize + 1 )
.head 5 -  Call GetComputerNameA( sCOMPUTERNAME, nSize )
.head 5 -  Set sCOMPUTERNAME = SalStrLeftX( sCOMPUTERNAME, nSize )
.head 5 +  If sCOMPUTERNAME = STRING_Null
.head 6 -  ! When API has failed check the environemt settings
.head 6 -  Set sCOMPUTERNAME = VisDosGetEnvString( 'COMPUTERNAME' )
.head 5 -  Return sCOMPUTERNAME
.head 3 +  Function: SalSysGetUserName
.head 4 -  Description: author: taken from C. Astor sample
date:     ???
version: 1.00

desc:
Returns the username
.head 4 +  Returns
.head 5 -  String:
.head 4 -  Parameters
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nSize
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  String: sBuffer
.data INHERITPROPS
0000: 0100
.enddata
.head 4 +  Actions
.head 5 -  Set nSize = 50
.head 5 -  Call SalStrSetBufferLength( sBuffer, nSize )
.head 5 -  Call GetUserNameA( sBuffer, nSize )
.head 5 -  Return sBuffer
.head 3 +  Function: SalSysGetIP
.head 4 -  Description: 
author: 	??? (extracted from winsock.apl)
date:	???
version:

desc:
Returns the IP address of a given hostname

example:
Set lsIP = SalSysGetIP('MyComputer_NT')
.head 4 +  Returns
.head 5 -  String:
.head 4 +  Parameters
.head 5 -  String: spHostName
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  !
.head 5 -  Number: nLowVersion
.head 5 -  Number: nHighVersion
.head 5 -  Number: nMaxSockets
.head 5 -  Number: nMaxUp
.head 5 -  Number: nlpVendorInfo
.head 5 -  String: sSystemStatus
.head 5 -  String: sDescription
.head 5 -  String: sNull
.head 5 -  !
.head 5 -  Number: nStructPointer
.head 5 -  String: sIP
.head 5 -  String: spMem
.head 5 -  String: sStr
.head 5 -  !
.head 5 -  Number: nFarPointer
.head 5 -  Number: nLen
.head 4 +  Actions
.head 5 -  ! Init
.head 5 +  If WSAStartup(257,nLowVersion,nHighVersion,
	sDescription,sNull,sSystemStatus,
	nMaxSockets,nMaxUp,nlpVendorInfo ) != 0
.head 6 -  Return ''
.head 5 -  !
.head 5 -  Set nStructPointer = gethostbyname( spHostName )
.head 5 +  If nStructPointer = NUMBER_Null or nStructPointer = 0
.head 6 -  ! Call SalMessageBox( 'Connection failed - ' || SalNumberToStrX( WSAGetLastError(  ), 0 ), 'Error', 0 )
.head 6 -  Return ''
.head 5 -  !
.head 5 -  Call SalStrSetBufferLength( spMem, 1000 )
.head 5 -  Call CStructCopyFromFarMem( nStructPointer, spMem, 1000 )
.head 5 -  !
.head 5 -  Set nFarPointer = CStructGetFarPointer( spMem, 12 )
.head 5 -  !
.head 5 -  Call SalStrSetBufferLength( sStr, 4 )
.head 5 -  Call CStructCopyFromFarMem( nFarPointer, sStr, 4 )
.head 5 -  Set nFarPointer = CStructGetFarPointer( sStr, 0 )
.head 5 -  Call SalStrSetBufferLength( sStr, 4 )
.head 5 -  Call CStructCopyFromFarMem( nFarPointer, sStr, 4 )
.head 5 -  Set nFarPointer = CStructGetFarPointer( sStr, 0 )
.head 5 -  !
.head 5 -  Set nFarPointer = inet_ntoa( nFarPointer )
.head 5 -  Set nLen = lstrlen( nFarPointer ) + 1
.head 5 -  Call SalStrSetBufferLength( sIP, nLen )
.head 5 -  Call CStructCopyFromFarMem( nFarPointer, sIP, nLen )
.head 5 -  ! Close
.head 5 -  Call WSACleanup(  )
.head 5 -  !
.head 5 -  Return sIP
.head 3 +  Function: SalSysGetDriveInfo
.head 4 -  Description: author: 	Philippe Gibone
date:  	10/07/2002
version 	1.0

desc: 	Retrieves Disks info
 
example:
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  FunctionalVar: aDrive[*]
.head 6 -  Class: sDriveInfo
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nLogicalDrive
.head 5 -  String: sDriveListe[*]
.head 5 -  Number: i
.head 5 -  String: sSerial
.head 5 -  ! Spécifique GetDiskFreeSpaceEx
.head 5 -  Number: nFreeCaller
.head 5 -  String: sFree
.head 5 -  String: sTotal
.head 5 -  Number: nTotal
.head 5 -  Number: nFree
.head 5 -  Number: nTemp
.head 5 -  ! Spécifique GetVolumeInformation
.head 5 -  String: sLabel
.head 5 -  Number: nLabel
.head 5 -  Number: nSerial
.head 5 -  Number: nComponent
.head 5 -  Number: nFlags
.head 5 -  String: sFileSystem
.head 5 -  Number: nFileSystem
.head 4 +  Actions
.head 5 -  Set nLogicalDrive =VisDosEnumDrives(sDriveListe)
.head 5 -  Set i = 0
.head 5 -  Set nTotal = CStructAllocFarMem( 8 )
.head 5 -  Set nFree = CStructAllocFarMem( 8 )
.head 5 -  Set nFreeCaller = CStructAllocFarMem( 8 )
.head 5 +  Loop
.head 6 +  If i >= nLogicalDrive
.head 7 -  Break
.head 6 -  Set aDrive[i].nDriveType = VisDosGetDriveType(sDriveListe[i])
.head 6 -  Set sLabel = ""
.head 6 -  Set sFileSystem = ""
.head 6 -  Set nSerial = 0
.head 6 -  Set nComponent = 0
.head 6 -  Set nFlags = 0
.head 6 -  Set aDrive[i].nSize = 0
.head 6 -  Set aDrive[i].nFree = 0
.head 6 -  Set nLabel = 100
.head 6 -  Set nFileSystem =100
.head 6 -  Call SalStrSetBufferLength(sLabel, nLabel)
.head 6 -  Call SalStrSetBufferLength(sFileSystem, nFileSystem)
.head 6 -  Set aDrive[i].sLetter 	= sDriveListe[i]
.head 6 +  If GetVolumeInformationA( sDriveListe[i] || "\\", sLabel, nLabel, nSerial, nComponent, nFlags, sFileSystem, nFileSystem)
.head 7 -  Set aDrive[i].sLabel	 	= sLabel
.head 7 -  Set aDrive[i].sFileSystem 	= sFileSystem
.head 6 +  Else
.head 7 -  Set aDrive[i].sLabel	 	= ""
.head 7 -  Set aDrive[i].sFileSystem 	= ""
.head 6 -  Call SalStrSetBufferLength(sFree, 8)
.head 6 -  Call SalStrSetBufferLength(sTotal, 8)
.head 6 -  Call CStructPutLong(sTotal, 0, 0)
.head 6 -  Call CStructPutLong(sTotal, 4, 0)
.head 6 -  Call GetDiskFreeSpaceExA(  sDriveListe[i], nFreeCaller, nTotal , nFree)
.head 6 -  Call CStructCopyFromFarMem( nTotal, sTotal, 8 )
.head 6 -  Call CStructCopyFromFarMem( nFree, sFree, 8 )
.head 6 -  Set nTemp = CStructGetLong(sTotal, 0) / 1024 / 1024
.head 6 +  If nTemp < 0
.head 7 -  Set nTemp = 4096 + nTemp
.head 6 -  Set aDrive[i].nSize = nTemp + CStructGetLong(sTotal, 4) * 4096
.head 6 -  Set nTemp = CStructGetLong(sFree, 0) / 1024 / 1024
.head 6 +  If nTemp < 0
.head 7 -  Set nTemp = 4096 + nTemp
.head 6 -  Set aDrive[i].nFree =  nTemp + CStructGetLong(sFree, 4) * 4096
.head 6 -  Set aDrive[i].nSerial = nSerial
.head 6 -  Set sSerial = '00000000' || SalNumberToHex(nSerial)
.head 6 -  Set aDrive[i].sSerial = SalStrMidX(sSerial, SalStrLength(sSerial) - 8, 4) || '-' || SalStrRightX(sSerial, 4)
.head 6 -  Set aDrive[i].nFileNameLength = nComponent
.head 6 -  Set aDrive[i].nFlags = nFlags
.head 6 -  Set aDrive[i].sFlags = SalNumberToHex(nFlags)
.head 6 +  Select Case aDrive[i].nDriveType
.head 7 +  Case DRIVE_Floppy
.head 8 -  Set aDrive[i].sDriveType = "Floppy"
.head 8 -  Break
.head 7 +  Case DRIVE_Fixed
.head 8 -  Set aDrive[i].sDriveType = "Fixed Drive"
.head 8 -  Break
.head 7 +  Case DRIVE_Network
.head 8 -  Set aDrive[i].sDriveType = "Network Drive"
.head 8 -  Break
.head 7 +  Case DRIVE_CDROM
.head 8 -  Set aDrive[i].sDriveType = "CD-ROM"
.head 8 -  Break
.head 7 +  Case DRIVE_RAM
.head 8 -  Set aDrive[i].sDriveType = "RAM Drive"
.head 8 -  Break
.head 7 +  Default
.head 8 -  Set aDrive[i].sDriveType = "Unknown"
.head 8 -  Break
.head 6 -  Set i = i + 1
.head 5 -  Call CStructFreeFarMem( nTotal )
.head 5 -  Call CStructFreeFarMem( nFree )
.head 5 -  Call CStructFreeFarMem( nFreeCaller )
.head 5 -  Return nLogicalDrive
.head 3 +  Function: SalSysGetPrinterInfo
.head 4 -  Description: author: 	Philippe Gibone
date:  	10/07/2002
version 	1.0

desc: 	Retrieves Printers info
 
example:
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  FunctionalVar: aPrinterInfo[*]
.head 6 -  Class: sPrinterInfo
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  String: sPrinterEnum
.head 5 -  Number: nNeed
.head 5 -  Number: nReturned
.head 5 -  Number: nAdresse
.head 5 -  String: sPrinterName
.head 5 -  String: sPort
.head 5 -  Number: i
.head 5 -  Number: nTotal
.head 4 +  Actions
.head 5 -  Call SalStrSetBufferLength(sPrinterEnum, 1000)
.head 5 -  Call EnumPrintersA( 2, 0, 5, sPrinterEnum, 0, nNeed, nReturned )
.head 5 +  If nNeed = 0
.head 6 -  Return 0
.head 5 +  Else
.head 6 -  Call EnumPrintersA( 2, 0, 5, sPrinterEnum, nNeed, nNeed, nReturned )
.head 6 -  Set i = 0
.head 6 +  Loop
.head 7 +  If i >= nReturned
.head 8 -  Break
.head 7 -  Set nAdresse = CStructGetFarPointer( sPrinterEnum, 20 * i )
.head 7 +  If nAdresse != 0
.head 8 -  Call SalStrSetBufferLength(sPrinterName, 1000)
.head 8 -  Call CStructCopyFromFarMem( nAdresse, sPrinterName, 1000 )
.head 8 -  Set aPrinterInfo[i].sPrinterName = SalStrLeftX(sPrinterName, SalStrLength(sPrinterName))
.head 7 -  Set nAdresse = CStructGetFarPointer( sPrinterEnum, 20 * i + 4 )
.head 7 +  If nAdresse != 0
.head 8 -  Call SalStrSetBufferLength(sPort, 1000)
.head 8 -  Call CStructCopyFromFarMem( nAdresse, sPort, 1000 )
.head 8 -  Set aPrinterInfo[i].sPort = SalStrLeftX(sPort, SalStrLength(sPort))
.head 7 -  Set aPrinterInfo[i].nAttribute =  CStructGetLong( sPrinterEnum, 20 * i + 8 )
.head 7 -  Set aPrinterInfo[i].sAttribute  = ""
.head 7 +  If aPrinterInfo[i].nAttribute & PRINTER_ATT_DEFAULT
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "DEFAULT + "
.head 7 +  If aPrinterInfo[i].nAttribute & PRINTER_ATT_SHARED
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "SHARED + "
.head 7 +  If aPrinterInfo[i].nAttribute & PRINTER_ATT_NETWORK
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "NETWORK +"
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_QUEUED
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "QUEUED + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_DIRECT
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "DIRECT + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_HIDDEN
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "HIDDEN + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_LOCAL
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "LOCAL + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_ENABLE_DEVQ
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "ENABLE_DEVQ + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_KEEPPRINTEDJOBS
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "KEEPPRINTEDJOBS + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_COMPLETE_FIRST
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "DO_COMPLETE_FIRST + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_WORK_OFFLINE
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "WORK_OFFLINE + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_ENABLE_BIDI
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "ENABLE_BIDI + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_RAW_ONLY
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "RAW_ONLY + "
.head 7 +  If aPrinterInfo[i].nAttribute &  PRINTER_ATT_PUBLISHED
.head 8 -  Set aPrinterInfo[i].sAttribute = aPrinterInfo[i].sAttribute || "PUBLISHED + "
.head 7 -  Set aPrinterInfo[i].sAttribute  = '0x' || SalNumberToHex(aPrinterInfo[i].nAttribute) || ' = '  ||  SalStrLeftX(aPrinterInfo[i].sAttribute, SalStrLength(aPrinterInfo[i].sAttribute) - 3)
.head 7 -  Set i = i + 1
.head 6 -  Set nTotal = nReturned
.head 5 -  Call SalStrSetBufferLength(sPrinterEnum, 1000)
.head 5 -  Set nNeed = 0
.head 5 -  Set nReturned = 0
.head 5 -  Call EnumPrintersA( 4, 0, 4, sPrinterEnum, 0, nNeed, nReturned )
.head 5 +  If nNeed = 0
.head 6 -  Return nTotal
.head 5 +  Else
.head 6 -  Call EnumPrintersA( 4, 0, 4, sPrinterEnum, nNeed, nNeed, nReturned )
.head 6 -  Set i = 0
.head 6 +  Loop
.head 7 +  If i >= nReturned
.head 8 -  Break
.head 7 -  Set nAdresse = CStructGetFarPointer( sPrinterEnum, 12 * i )
.head 7 +  If nAdresse != 0
.head 8 -  Call SalStrSetBufferLength(sPrinterName, 1000)
.head 8 -  Call CStructCopyFromFarMem( nAdresse, sPrinterName, 1000 )
.head 8 -  Set aPrinterInfo[nTotal + i].sPrinterName = SalStrLeftX(sPrinterName, SalStrLength(sPrinterName))
.head 7 -  Set nAdresse = CStructGetFarPointer( sPrinterEnum, 12 * i + 4 )
.head 7 +  If nAdresse != 0
.head 8 -  Call SalStrSetBufferLength(sPort, 1000)
.head 8 -  Call CStructCopyFromFarMem( nAdresse, sPort, 1000 )
.head 8 -  Set aPrinterInfo[nTotal + i].sServerName = SalStrLeftX(sPort, SalStrLength(sPort))
.head 7 -  Set aPrinterInfo[nTotal + i].nAttribute =  CStructGetLong( sPrinterEnum, 12 * i + 8 )
.head 7 -  Set aPrinterInfo[nTotal + i].sAttribute  = ""
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_DEFAULT
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "DEFAULT + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_SHARED
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "SHARED + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_NETWORK
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "NETWORK + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_QUEUED
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "QUEUED + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_DIRECT
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "DIRECT + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_HIDDEN
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "HIDDEN + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_LOCAL
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "LOCAL + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_ENABLE_DEVQ
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "ENABLE_DEVQ + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_KEEPPRINTEDJOBS
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "KEEPPRINTEDJOBS + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_COMPLETE_FIRST
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "DO_COMPLETE_FIRST + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_WORK_OFFLINE
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "WORK_OFFLINE + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_ENABLE_BIDI
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "ENABLE_BIDI + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_RAW_ONLY
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "RAW_ONLY + "
.head 7 +  If aPrinterInfo[nTotal + i].nAttribute & PRINTER_ATT_PUBLISHED
.head 8 -  Set aPrinterInfo[nTotal + i].sAttribute = aPrinterInfo[nTotal + i].sAttribute || "PUBLISHED + "
.head 7 -  Set aPrinterInfo[nTotal + i].sAttribute  = '0x' || SalNumberToHex(aPrinterInfo[nTotal + i].nAttribute) || ' = '  ||  SalStrLeftX(aPrinterInfo[nTotal + i].sAttribute, SalStrLength(aPrinterInfo[nTotal + i].sAttribute) - 3)
.head 7 -  Set i = i + 1
.head 6 -  Return nTotal + nReturned
.head 3 +  Function: SalSysGetDisplayInfo
.head 4 -  Description: author: 	Philippe Gibone
date:  	10/07/2002
version 	1.0

desc: 	Retrieves Display info
 
example:
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  FunctionalVar: aDisplayInfo[*]
.head 6 -  Class: sDisplayInfo
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nHorizontalSet
.head 5 -  Number: nVerticalSet
.head 5 -  Number: nBitPerPixelSet
.head 5 -  String: sDisplayEnum
.head 5 -  Number: i
.head 5 -  Number: hDC
.head 4 +  Actions
.head 5 -  Set hDC = GetDC( hWndForm )
.head 5 -  Set nHorizontalSet = GetDeviceCaps( hDC, HORZRES )
.head 5 -  Set nVerticalSet = GetDeviceCaps( hDC, VERTRES )
.head 5 -  Set nBitPerPixelSet = GetDeviceCaps( hDC, BITSPIXEL )
.head 5 -  Call ReleaseDC(hWndForm, hDC)
.head 5 -  Set i = 0
.head 5 -  Call SalStrSetBufferLength(sDisplayEnum, 1000)
.head 5 +  While EnumDisplaySettingsA( 0, i, sDisplayEnum)
.head 6 -  Set aDisplayInfo[i].nBitsPerPixel	 = CStructGetLong(sDisplayEnum, 104)
.head 6 -  Set aDisplayInfo[i].nHorizontal 	= CStructGetLong(sDisplayEnum, 108)
.head 6 -  Set aDisplayInfo[i].nVertical 		= CStructGetLong(sDisplayEnum, 112)
.head 6 -  Set aDisplayInfo[i].nFrequency 	= CStructGetLong(sDisplayEnum, 120)
.head 6 +  If aDisplayInfo[i].nBitsPerPixel = nBitPerPixelSet AND aDisplayInfo[i].nHorizontal = nHorizontalSet AND aDisplayInfo[i].nVertical = nVerticalSet
.head 7 -  Set aDisplayInfo[i].bCurrent = TRUE
.head 6 +  Else
.head 7 -  Set aDisplayInfo[i].bCurrent = FALSE
.head 6 -  Set i = i + 1
.head 5 -  Return i
.head 3 +  Function: SalSysGetPortInfo
.head 4 -  Description: author: 	Philippe Gibone
date:  	10/01/2003
version 	1.0

desc: 	Retrieves Ports info
 
.head 4 +  Returns
.head 5 -  Number:
.head 4 +  Parameters
.head 5 -  FunctionalVar: aPortInfo[*]
.head 6 -  Class: sPortInfo
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nNeeded
.head 5 -  Number: nReturned
.head 5 -  Number: i
.head 5 -  String: sPortType
.head 5 -  String: sBuffer
.head 5 -  Number: nSize
.head 5 -  Number: nLength
.head 5 -  Number: nAddress
.head 5 -  String: sTemp
.head 4 +  Actions
.head 5 -  Call aPortInfo[0].Init()
.head 5 -  Set nSize = sPortInfo.nSize
.head 5 -  Call GetPortNumber( 0, 2, 0, 0, nNeeded, nReturned )
.head 5 +  If nNeeded
.head 6 -  Call SalStrSetBufferLength( sBuffer, nNeeded + 1 )
.head 6 -  Call EnumPort( 0, 2, sBuffer, nNeeded, nNeeded, nReturned )
.head 6 -  Set i = 0
.head 6 +  While i < nReturned
.head 7 -  Set aPortInfo[i].sPortName 		= ''
.head 7 -  Set aPortInfo[i].sMonitorName 	= ''
.head 7 -  Set aPortInfo[i].sDescription 		= ''
.head 7 -  Set aPortInfo[i].nPortType 		= 0
.head 7 -  Set aPortInfo[i].nReserved 		= 0
.head 7 -  Set aPortInfo[i].sPortType 		= ''
.head 7 -  Set nAddress = CStructGetLong(sBuffer, i * nSize)
.head 7 -  Set nLength = lstrlen(nAddress)
.head 7 +  If nLength != 0
.head 8 -  Call SalStrSetBufferLength( sTemp, nLength + 1)
.head 8 -  Call CStructCopyFromFarMem( nAddress, sTemp, nLength + 1 )
.head 8 -  Set aPortInfo[i].sPortName = sTemp
.head 7 -  Set nAddress = CStructGetLong(sBuffer, i * nSize + 4)
.head 7 -  Set nLength = lstrlen(nAddress)
.head 7 +  If nLength != 0
.head 8 -  Call SalStrSetBufferLength( sTemp, nLength + 1)
.head 8 -  Call CStructCopyFromFarMem( nAddress, sTemp, nLength + 1 )
.head 8 -  Set aPortInfo[i].sMonitorName = sTemp
.head 7 -  Set nAddress = CStructGetLong(sBuffer, i * nSize + 8)
.head 7 -  Set nLength = lstrlen(nAddress)
.head 7 +  If nLength != 0
.head 8 -  Call SalStrSetBufferLength( sTemp, nLength + 1)
.head 8 -  Call CStructCopyFromFarMem( nAddress, sTemp, nLength + 1 )
.head 8 -  Set aPortInfo[i].sDescription = sTemp
.head 7 -  Set aPortInfo[i].nPortType =  CStructGetLong(sBuffer, i * nSize + 12)
.head 7 -  Set aPortInfo[i].nReserved =  CStructGetLong(sBuffer, i * nSize + 16)
.head 7 +  If aPortInfo[i].nPortType &  PORT_TYPE_WRITE
.head 8 -  Set aPortInfo[i].sPortType = 'Write & '
.head 7 +  If aPortInfo[i].nPortType &  PORT_TYPE_READ
.head 8 -  Set aPortInfo[i].sPortType =  aPortInfo[i].sPortType || 'Read & '
.head 7 +  If aPortInfo[i].nPortType &  PORT_TYPE_REDIRECTED
.head 8 -  Set aPortInfo[i].sPortType = aPortInfo[i].sPortType || 'Redirected & '
.head 7 +  If aPortInfo[i].nPortType &  PORT_TYPE_NET_ATTACHED
.head 8 -  Set aPortInfo[i].sPortType = aPortInfo[i].sPortType || 'Network & '
.head 7 -  Set aPortInfo[i].sPortType = SalStrLeftX(aPortInfo[i].sPortType, SalStrLength(aPortInfo[i].sPortType) - 2)
.head 7 -  Set i = i + 1
.head 5 -  Return nReturned
.head 3 +  Function: SalSysGetOSVersion
.head 4 -  Description: author:	© Christian Astor
    	- Adresse E-mail : 	castorix@club-internet.fr
    	- Adresse ICQ (UIN) :	4396797
date:	®  ???
version:	1.00

desc:
Returns the version of the OS.

parameter:
String: sVersion is returned, contaiing OS information

Return Value:a number, defined as constant. Possible return values:
VERSION_OS_95		= 0
VERSION_OS_95_OSR1	= 1
VERSION_OS_95_OSR2	= 2
VERSION_OS_95_OSR21	= 3
VERSION_OS_95_OSR25	= 4
VERSION_OS_98		= 5
VERSION_OS_98_SE	= 6
VERSION_OS_NT_351	= 7
VERSION_OS_NT_4	= 8
VERSION_OS_2000	= 9
VERSION_OS_ME		= 10
VERSION_OS_WHISTLER	= 11

example:

Select Case SalSysGetOSVersion( sVersion )
  Case VERSION_OS_95
       ...
       Break
  Case VERSION_OS_2000
       ...
       Break

.head 4 +  Returns
.head 5 -  Number: nVersion
.head 4 +  Parameters
.head 5 +  Receive String: sVersion
.head 6 -  ! the version string as retrun value
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Number: nStructSize
.head 5 -  Number: nMajorVersion
.head 5 -  Number: nMinorVersion
.head 5 -  Number: nBuildNumber
.head 5 -  Number: nPlatformId
.head 5 -  String: sCSDVersion
.head 5 -  String: sCSD
.head 4 +  Actions
.head 5 -  Set nStructSize = 156
.head 5 -  Call SalStrSetBufferLength( sCSDVersion,128 )
.head 5 -  Call GetVersionExA( nStructSize, nMajorVersion, nMinorVersion, nBuildNumber, nPlatformId, sCSDVersion )
.head 5 -  Set sVersion =SalNumberToStrX( nMajorVersion, 0 )  || "." || SalStrRepeatX( "0", SalStrLength(SalNumberToStrX( nMinorVersion, 0 ) )) ||
 SalNumberToStrX( nMinorVersion, 0 ) || "." || SalNumberToStrX( nBuildNumber & 0xFFFF, 0 )
.head 5 -  Call SalStrSetBufferLength( sCSD,129 )
.head 5 -  Call CStructGetString( sCSDVersion, 0,  SalStrLength(sCSDVersion) + 1, sCSD )
.head 5 -  Set sVersion = sVersion ||  sCSD
.head 5 +  If nPlatformId = VER_PLATFORM_WIN32_NT
.head 6 +  If nMajorVersion = 3 and nMinorVersion = 51
.head 7 -  Return VERSION_OS_NT_351
.head 6 +  Else If nMajorVersion  = 4 and nMinorVersion = 0
.head 7 -  Return VERSION_OS_NT_4
.head 6 +  Else If nMajorVersion  = 5 and nMinorVersion = 0
.head 7 -  Return VERSION_OS_2000
.head 6 +  Else If nMajorVersion  = 5 and nMinorVersion = 1
.head 7 -  Return VERSION_OS_WHISTLER
.head 6 +  Else
.head 7 -  Call SalMessageBox('don\'t know, what kind of WinOs mayber WinXP?','STOP',MB_IconStop)
.head 7 -  Return 0
.head 5 +  Else If nPlatformId = VER_PLATFORM_WIN32_WINDOWS
.head 6 +  If nMajorVersion = 4  and nMinorVersion = 0
.head 7 +  If sCSDVersion = " A"
.head 8 -  Return VERSION_OS_95_OSR1
.head 7 +  Else If sCSDVersion = " B"
.head 8 -  ! If SalNumberLow(nTemp1) = 1111
.head 8 -  Return VERSION_OS_95_OSR2
.head 7 +  Else
.head 8 -  Return VERSION_OS_95
.head 6 +  Else If nMajorVersion = 4  and nMinorVersion = 3
.head 7 +  If sCSDVersion = " B"
.head 8 -  Return VERSION_OS_95_OSR21
.head 7 +  Else If sCSDVersion = " C"
.head 8 -  Return VERSION_OS_95_OSR25
.head 6 +  Else If nMajorVersion = 4  and nMinorVersion = 10
.head 7 +  If sCSDVersion = " A"
.head 8 -  Return VERSION_OS_98_SE
.head 7 +  Else
.head 8 -  Return VERSION_OS_98
.head 6 +  Else If nMajorVersion = 4  and nMinorVersion = 90
.head 7 -  Return VERSION_OS_ME
.head 3 +  Function: SalSysPing
.head 4 -  Description: author: 	Stefane Beltrame?? (posted by him)
date:  	28.07.2003
version 	1.0

desc: 	Pings another computer and returns a boolean if successful, or not.
.head 4 +  Returns
.head 5 -  Boolean:
.head 4 +  Parameters
.head 5 -  String: p_sTarget
.head 5 -  Number: p_nTimeout
.head 4 -  Static Variables
.head 4 +  Local variables
.head 5 -  Boolean: bOk
.head 5 -  Number: nTarget
.head 5 -  !
.head 5 -  Number: nWSADataPtr
.head 5 -  Boolean: bWSAStartupOk
.head 5 -  !
.head 5 -  Number: nIcmpHandle
.head 5 -  Number: nRet
.head 5 -  !
.head 5 -  Number: nReplyBufferPtr
.head 5 -  Number: nLowVersion
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  Number: nHighVersion
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  String: sDescription
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  String: sNull
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  String: sSystemStatus
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  Number: nMaxSockets
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  Number: nMaxUp
.data INHERITPROPS
0000: 0100
.enddata
.head 5 -  Number: nlpVendorInfo
.data INHERITPROPS
0000: 0100
.enddata
.head 4 +  Actions
.head 5 -  Set bOk = TRUE
.head 5 -  ! Translate IP addr string to number
.head 5 +  If bOk
.head 6 -  Set nTarget = inet_addr(p_sTarget)
.head 6 -  Set bOk = (nTarget != 0xFFFFFFFF)
.head 5 -  !
.head 5 -  ! Allocate WSAData memory for WSAStartup()
.head 5 +  If bOk
.head 6 -  Set nWSADataPtr = CStructAllocFarMem(526)
.head 6 -  Set bOk = (nWSADataPtr != 0)
.head 5 -  ! Call WSAStartup
.head 5 +  If bOk
.head 6 -  Set bWSAStartupOk = (WSAStartup(0x0101,nLowVersion,nHighVersion,
	sDescription,sNull,sSystemStatus,
	nMaxSockets,nMaxUp,nlpVendorInfo) = 0)
.head 6 -  ! Set bWSAStartupOk = (WSAStartup(0x0101, nWSADataPtr) = 0)
.head 6 -  ! (257,nLowVersion,nHighVersion,
	sDescription,sNull,sSystemStatus,
	nMaxSockets,nMaxUp,nlpVendorInfo )
.head 6 -  Set bOk = bWSAStartupOk
.head 5 -  !
.head 5 -  ! Allocate ICMP_ECHO_REPLY memory for IcmpSendEcho()
.head 5 +  If bOk
.head 6 -  Set nReplyBufferPtr = CStructAllocFarMem(256)
.head 6 -  Set bOk = (nReplyBufferPtr != 0)
.head 5 -  ! Create IcmpHandle
.head 5 +  If bOk
.head 6 -  Set nIcmpHandle = IcmpCreateFile()
.head 6 -  Set bOk = (nIcmpHandle != 0)
.head 5 -  ! Ping
.head 5 +  If bOk
.head 6 -  Set nRet = IcmpSendEcho(nIcmpHandle,
	nTarget,
	0, 0,
	255, 0, 0, 0, 0,
	nReplyBufferPtr, 256,
	p_nTimeout)
.head 6 -  Set bOk = (nRet != 0)
.head 5 -  ! Close IcmpHandle
.head 5 +  If nIcmpHandle != 0
.head 6 -  Call IcmpCloseHandle(nIcmpHandle)
.head 6 -  Set nIcmpHandle = 0
.head 5 -  ! Free ICMP_ECHO_REPLY memory
.head 5 +  If nReplyBufferPtr != 0
.head 6 -  Call CStructFreeFarMem(nReplyBufferPtr)
.head 6 -  Set nReplyBufferPtr = 0
.head 5 -  !
.head 5 -  ! Call WSACleanup
.head 5 +  If bWSAStartupOk
.head 6 -  Call WSACleanup()
.head 5 -  ! Free WSAData memory
.head 5 +  If nWSADataPtr != 0
.head 6 -  Call CStructFreeFarMem(nWSADataPtr)
.head 6 -  Set nWSADataPtr = 0
.head 5 -  !
.head 5 -  Return bOk
.head 2 -  Named Menus
.head 2 +  Class Definitions
.head 3 +  Functional Class: sDriveInfo
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sLetter
.head 5 -  String: sLabel
.head 5 -  String: sFileSystem
.head 5 -  String: sDriveType
.head 5 -  Number: nSerial
.head 5 -  String: sSerial
.head 5 -  Number: nFileNameLength
.head 5 -  Number: nFlags
.head 5 -  String: sFlags
.head 5 -  Number: nDriveType
.head 5 -  Number: nSize
.head 5 -  Number: nFree
.head 4 -  Functions
.head 3 +  Functional Class: sPrinterInfo
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sPrinterName
.head 5 -  String: sPort
.head 5 -  String: sServerName
.head 5 -  Number: nAttribute
.head 5 -  String: sAttribute
.head 4 -  Functions
.head 3 +  Functional Class: sDisplayInfo
.head 4 -  Description:
.head 4 -  Derived From
.head 4 -  Class Variables
.head 4 +  Instance Variables
.head 5 -  String: sColour
.head 5 -  Number: nHorizontal
.head 5 -  Number: nVertical
.head 5 -  Number: nBitsPerPixel
.head 5 -  Number: nFrequency
.head 5 -  Boolean: bCurrent
.head 4 -  Functions
.head 3 +  Functional Class: sPortInfo
.head 4 -  Description:
.head 4 -  Derived From
.head 4 +  Class Variables
.head 5 -  Number: nSize
.head 4 +  Instance Variables
.head 5 -  String: sPortName
.head 5 -  String: sMonitorName
.head 5 -  String: sDescription
.head 5 -  Number: nPortType
.head 5 -  Number: nReserved
.head 5 -  String: sPortType
.head 4 +  Functions
.head 5 +  Function: Init
.head 6 -  Description:
.head 6 -  Returns
.head 6 -  Parameters
.head 6 -  Static Variables
.head 6 -  Local variables
.head 6 +  Actions
.head 7 -  Set nSize = 20
.head 2 +  Default Classes
.head 3 -  MDI Window: cBaseMDI
.head 3 -  Form Window:
.head 3 -  Dialog Box:
.head 3 -  Table Window:
.head 3 -  Quest Window:
.head 3 -  Data Field:
.head 3 -  Spin Field:
.head 3 -  Multiline Field:
.head 3 -  Pushbutton:
.head 3 -  Radio Button:
.head 3 -  Option Button:
.head 3 -  Check Box:
.head 3 -  Child Table:
.head 3 -  Quest Child Window: cQuickDatabase
.head 3 -  List Box:
.head 3 -  Combo Box:
.head 3 -  Picture:
.head 3 -  Vertical Scroll Bar:
.head 3 -  Horizontal Scroll Bar:
.head 3 -  Column:
.head 3 -  Background Text:
.head 3 -  Group Box:
.head 3 -  Line:
.head 3 -  Frame:
.head 3 -  Custom Control:
.head 3 -  ActiveX:
.head 2 -  Application Actions
